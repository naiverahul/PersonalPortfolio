<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rahul Agarwal &mdash; Blogs</title>
  <!-- Google Fonts - Roboto -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <!-- Feather Icons -->
  <script src="https://unpkg.com/feather-icons"></script>
  <!-- Custom CSS -->
  <link rel="stylesheet" href="style.css">
  <style>
    /* Blog post styles */
    .blog-post {
      display: none;
      background: white;
      padding: 2rem;
      border-radius: var(--border-radius-md);
      margin-top: var(--spacing-lg);
      border-left: 4px solid var(--primary-color);
    }
    
    .blog-post.active {
      display: block;
    }
    
    .blog-post-title {
      font-size: 2rem;
      color: var(--primary-color);
      margin-bottom: var(--spacing-sm);
    }
    
    .blog-post-meta {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      color: var(--text-light);
    }
    
    .blog-post-content {
      line-height: 1.8;
    }
    
    .blog-post-content h2 {
      font-size: 1.7rem;
      margin: 2rem 0 1rem;
      color: var(--primary-color);
    }
    
    .blog-post-content h3 {
      font-size: 1.4rem;
      margin: 1.5rem 0 1rem;
      color: var(--secondary-color);
    }
    
    .blog-post-content pre {
      background: #f5f7f9;
      border-radius: 5px;
      padding: 1rem;
      overflow-x: auto;
      margin: 1.5rem 0;
    }
    
    .blog-post-content code {
      font-family: monospace;
    }
    
    .blog-post-content ul,
    .blog-post-content ol {
      margin-left: 1.5rem;
      margin-bottom: 1.5rem;
    }
    
    .back-to-posts {
      display: inline-flex;
      align-items: center;
      margin-bottom: var(--spacing-md);
      color: var(--accent-color);
      font-weight: 500;
      cursor: pointer;
    }
    
    .back-to-posts svg {
      margin-right: 0.5rem;
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="header-content">
      <h1>Rahul Agarwal</h1>
      <p class="subtitle">Reading once a day keeps ChatGPT away</p>
      <p class="college-info">IIIT, Delhi</p>
      <nav>
        <a href="index.html">About</a>
        <a href="blogs.html" class="active">Blogs</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <!-- Blog listing section -->
    <section class="blogs" id="blog-listing">
      <div class="section-header">
        <h2>Latest Posts</h2>
        <div class="underline"></div>
      </div>
      
      <div class="post-list">
        <article class="post">
          <div class="post-date">
            <span>April 15, 2025</span>
          </div>
          <h3>Understanding Stochastic Gradient Descent</h3>
          <p>An intuitive guide to SGD and its applications in machine learning. Learn how this optimization algorithm helps train neural networks efficiently.</p>
          <div class="post-tags">
            <span>Machine Learning</span>
            <span>Neural Networks</span>
            <span>Optimization</span>
          </div>
          <a href="#" class="read-more" data-post="post-1">Read more <i data-feather="arrow-right"></i></a>
        </article>
        
        <article class="post">
          <div class="post-date">
            <span>April 28, 2025</span>
          </div>
          <h3>Building a Simple Maze-Solving Robot</h3>
          <p>Step-by-step walkthrough of robot logic and PID control algorithms. I cover everything from sensor integration to implementing the control loop for smooth navigation.</p>
          <div class="post-tags">
            <span>Robotics</span>
            <span>Algorithms</span>
            <span>Java</span>
          </div>
          <a href="#" class="read-more" data-post="post-2">Read more <i data-feather="arrow-right"></i></a>
        </article>
        
        <article class="post">
          <div class="post-date">
            <span>March 12, 2025</span>
          </div>
          <h3>Getting Started with libGDX</h3>
          <p>How to set up your first Angry Birds-like game using Java and libGDX. This tutorial covers project setup, physics implementation, and game mechanics fundamentals.</p>
          <div class="post-tags">
            <span>Game Development</span>
            <span>Java</span>
            <span>libGDX</span>
          </div>
          <a href="#" class="read-more" data-post="post-3">Read more <i data-feather="arrow-right"></i></a>
        </article>
        
        <article class="post">
          <div class="post-date">
            <span>February 5, 2025</span>
          </div>
          <h3>Python Data Structures Explained</h3>
          <p>An in-depth look at Python's built-in data structures and when to use each one. Improve your code efficiency by choosing the right structure for your needs.</p>
          <div class="post-tags">
            <span>Python</span>
            <span>Data Structures</span>
            <span>Performance</span>
          </div>
          <a href="#" class="read-more" data-post="post-4">Read more <i data-feather="arrow-right"></i></a>
        </article>


          <article class="post">
          <div class="post-date">
            <span>May 5, 2025</span>
          </div>
          <h3>Heap Data Structure in C++</h3>
          <p>Heap data structure is one of the most popular data structure in market. It leverages the properties of Complete binary tree and maintain data in a sorted way.  </p>
          <div class="post-tags">
            <span>C++</span>
            <span>Data Structures</span>
            <span>Interview</span>
          </div>
          <a href="#" class="read-more" data-post="post-5">Read more <i data-feather="arrow-right"></i></a>
        </article>
      </div>
    </section>
    
    <!-- Individual blog posts (initially hidden) -->
    <section class="blog-post" id="post-1">
      <a class="back-to-posts">
        <i data-feather="arrow-left"></i> Back to all posts
      </a>
      
      <h1 class="blog-post-title">Understanding Stochastic Gradient Descent</h1>
      <div class="blog-post-meta">
        <div class="post-date">
          <i data-feather="calendar"></i>
          <span>April 15, 2025</span>
        </div>
        <div class="post-tags">
          <span>Machine Learning</span>
          <span>Neural Networks</span>
          <span>Optimization</span>
        </div>
      </div>
      
      <div class="blog-post-content">
        <p>
          Stochastic Gradient Descent (SGD) is one of the most important algorithms in machine learning,
          particularly for training neural networks. In this post, we'll explore how SGD works, why it's 
          so effective, and how you can implement it in your own projects.
        </p>
        
        <h2>What is Gradient Descent?</h2>
        <p>
          Gradient descent is an optimization algorithm used to minimize a function by iteratively moving
          in the direction of the steepest descent as defined by the negative of the gradient. In machine learning,
          we use it to minimize the loss function of our models.
        </p>
        
        <h2>The "Stochastic" in SGD</h2>
        <p>
          While traditional gradient descent computes the gradient using the entire dataset, stochastic gradient
          descent approximates the gradient using a single sample or a small batch. This makes the algorithm:
        </p>
        <ul>
          <li>Faster per iteration</li>
          <li>Able to escape some local minima</li>
          <li>Suitable for online learning scenarios</li>
          <li>More memory-efficient for large datasets</li>
        </ul>
        
        <h2>Implementing SGD in Python</h2>
        <p>
          Here's a simple implementation of SGD in Python using NumPy:
        </p>
        <pre><code>
import numpy as np

def sgd_optimizer(X, y, model, learning_rate=0.01, epochs=100, batch_size=32):
    losses = []
    n_samples = X.shape[0]
    
    for epoch in range(epochs):
        # Shuffle the data
        indices = np.random.permutation(n_samples)
        X_shuffled = X[indices]
        y_shuffled = y[indices]
        
        # Batch processing
        for i in range(0, n_samples, batch_size):
            X_batch = X_shuffled[i:i+batch_size]
            y_batch = y_shuffled[i:i+batch_size]
            
            # Compute gradients
            gradients = model.compute_gradients(X_batch, y_batch)
            
            # Update weights
            model.update_weights(gradients, learning_rate)
            
        # Compute loss for the entire dataset
        current_loss = model.compute_loss(X, y)
        losses.append(current_loss)
        
        print(f"Epoch {epoch+1}/{epochs}, Loss: {current_loss:.4f}")
    
    return losses
        </code></pre>
        
        <h2>Conclusion</h2>
        <p>
          Stochastic Gradient Descent is a cornerstone algorithm in modern machine learning.
          By understanding how it works and its variants, you can improve the training of your models
          and tackle more complex problems.
        </p>
      </div>
    </section>
    
    <section class="blog-post" id="post-2">
      <a class="back-to-posts">
        <i data-feather="arrow-left"></i> Back to all posts
      </a>
      
      <h1 class="blog-post-title">Building a Simple Maze-Solving Robot</h1>
      <div class="blog-post-meta">
        <div class="post-date">
          <i data-feather="calendar"></i>
          <span>April 28, 2025</span>
        </div>
        <div class="post-tags">
          <span>Robotics</span>
          <span>Algorithms</span>
          <span>Java</span>
        </div>
      </div>
      
      <div class="blog-post-content">
        <p>
          Building a maze-solving robot is an excellent way to learn about robotics, sensors, and 
          algorithms. In this post, I'll share my experience building a robot that can navigate through
          complex mazes autonomously.
        </p>
        
        <h2>Robot Hardware Components</h2>
        <p>
          The robot consists of several key components:
        </p>
        <ul>
          <li>Microcontroller (Arduino)</li>
          <li>Infrared sensors for wall detection</li>
          <li>DC motors for movement</li>
          <li>Motor drivers</li>
          <li>Battery pack</li>
        </ul>
        
        <h2>Maze-Solving Algorithms</h2>
        <p>
          There are several algorithms that can be used for maze solving:
        </p>
        <h3>1. Wall Following</h3>
        <p>
          The simplest approach is the wall-following algorithm (also known as the left-hand or right-hand rule).
          The robot simply keeps its left (or right) side against a wall and follows it. This works for simple mazes
          but fails for mazes with islands.
        </p>
        
        <h3>2. Flood Fill</h3>
        <p>
          A more sophisticated approach is the flood fill algorithm. The robot maps the maze as it explores and
          assigns a distance value to each cell, representing the distance from the goal. The robot then always
          moves to the adjacent cell with the lowest value.
        </p>
        
        <h2>PID Control for Smooth Navigation</h2>
        <p>
          To ensure smooth navigation, I implemented a PID (Proportional-Integral-Derivative) controller
          that adjusts the motor speeds based on sensor readings. This allows the robot to make smooth turns
          and maintain a consistent distance from walls.
        </p>
        
        <pre><code>
// Simple PID controller implementation in Java
double kp = 0.5;  // Proportional gain
double ki = 0.2;  // Integral gain
double kd = 0.1;  // Derivative gain

double previousError = 0;
double integral = 0;

double pidControl(double error) {
    // Proportional term
    double p = kp * error;
    
    // Integral term
    integral += error;
    double i = ki * integral;
    
    // Derivative term
    double derivative = error - previousError;
    double d = kd * derivative;
    
    // Calculate total correction
    double correction = p + i + d;
    
    // Update previous error for next iteration
    previousError = error;
    
    return correction;
}
        </code></pre>
        
        <h2>Conclusion</h2>
        <p>
          Building a maze-solving robot is a challenging but rewarding project. The combination of 
          hardware integration, algorithm implementation, and control theory provides a comprehensive
          learning experience.
        </p>
      </div>
    </section>
    
    <section class="blog-post" id="post-3">
      <a class="back-to-posts">
        <i data-feather="arrow-left"></i> Back to all posts
      </a>
      
      <h1 class="blog-post-title">Getting Started with libGDX</h1>
      <div class="blog-post-meta">
        <div class="post-date">
          <i data-feather="calendar"></i>
          <span>March 12, 2025</span>
        </div>
        <div class="post-tags">
          <span>Game Development</span>
          <span>Java</span>
          <span>libGDX</span>
        </div>
      </div>
      
      <div class="blog-post-content">
        <p>
          LibGDX is a powerful, cross-platform game development framework that allows you to write your game 
          once and deploy it to desktop, mobile, and web platforms. In this tutorial, I'll guide you through 
          setting up a simple Angry Birds-like game.
        </p>
        
        <h2>Setting Up libGDX</h2>
        <p>
          To get started with libGDX, you need to set up your development environment:
        </p>
        <ol>
          <li>Install Java Development Kit (JDK) 8 or later</li>
          <li>Download the libGDX setup app</li>
          <li>Configure your project (choose platforms, modules, etc.)</li>
          <li>Generate the project and import it into your IDE</li>
        </ol>
        
        <h2>Implementing Game Physics</h2>
        <p>
          For our Angry Birds-like game, we'll use Box2D, a 2D physics engine that comes with libGDX.
          Here's how you can set up the physics world:
        </p>
        
        <pre><code>
// Create a physics world with gravity
World world = new World(new Vector2(0, -10), true);

// Create a physics body for a bird
BodyDef bodyDef = new BodyDef();
bodyDef.type = BodyDef.BodyType.DynamicBody;
bodyDef.position.set(5, 5);

// Create a circle shape for the bird
CircleShape circle = new CircleShape();
circle.setRadius(0.5f);

// Create a fixture definition
FixtureDef fixtureDef = new FixtureDef();
fixtureDef.shape = circle;
fixtureDef.density = 1.0f;
fixtureDef.friction = 0.3f;
fixtureDef.restitution = 0.5f; // Bounciness

// Create the body and fixture
Body body = world.createBody(bodyDef);
body.createFixture(fixtureDef);

// Clean up
circle.dispose();
        </code></pre>
        
        <h2>Game Mechanics</h2>
        <p>
          To implement the slingshot mechanic, we can use input handling to let players drag and release the bird:
        </p>
        
        <h3>Input Handling</h3>
        <p>
          LibGDX provides an input handling system that makes it easy to respond to user actions:
        </p>
        
        <pre><code>
@Override
public boolean touchDown(int screenX, int screenY, int pointer, int button) {
    Vector3 touchPos = new Vector3(screenX, screenY, 0);
    camera.unproject(touchPos);
    
    // Check if touch is on the bird
    if (isTouchOnBird(touchPos.x, touchPos.y)) {
        dragging = true;
        return true;
    }
    return false;
}

@Override
public boolean touchDragged(int screenX, int screenY, int pointer) {
    if (dragging) {
        Vector3 touchPos = new Vector3(screenX, screenY, 0);
        camera.unproject(touchPos);
        
        // Update bird position (with constraints for slingshot)
        updateBirdPosition(touchPos.x, touchPos.y);
        return true;
    }
    return false;
}

@Override
public boolean touchUp(int screenX, int screenY, int pointer, int button) {
    if (dragging) {
        dragging = false;
        
        // Calculate launch velocity based on drag distance
        launchBird();
        return true;
    }
    return false;
}
        </code></pre>
        
        <h2>Conclusion</h2>
        <p>
          LibGDX is a versatile framework that simplifies cross-platform game development. With its rich 
          set of features and modules, you can create professional-quality games without the complexity 
          of writing platform-specific code.
        </p>
      </div>
    </section>
    
    <section class="blog-post" id="post-4">
      <a class="back-to-posts">
        <i data-feather="arrow-left"></i> Back to all posts
      </a>
      
      <h1 class="blog-post-title">Python Data Structures Explained</h1>
      <div class="blog-post-meta">
        <div class="post-date">
          <i data-feather="calendar"></i>
          <span>February 5, 2025</span>
        </div>
        <div class="post-tags">
          <span>Python</span>
          <span>Data Structures</span>
          <span>Performance</span>
        </div>
      </div>
      
      <div class="blog-post-content">
        <p>
          Understanding Python's built-in data structures is essential for writing efficient and 
          elegant code. In this post, I'll explain the various data structures available in Python,
          their time complexities, and when to use each one.
        </p>
        
        <h2>Lists</h2>
        <p>
          Lists are the workhorse of Python data structures. They're mutable, ordered, and can contain
          elements of different types.
        </p>
        
        <h3>Time Complexities</h3>
        <ul>
          <li>Access: O(1)</li>
          <li>Append: O(1) (amortized)</li>
          <li>Insert: O(n)</li>
          <li>Delete: O(n)</li>
          <li>Search: O(n)</li>
        </ul>
        
        <h3>When to Use</h3>
        <p>
          Use lists when you need a mutable, ordered sequence that you frequently iterate over or access
          by index. They're versatile but not always the most efficient choice.
        </p>
        
        <h2>Dictionaries</h2>
        <p>
          Dictionaries are key-value stores that provide fast lookups by key.
        </p>
        
        <h3>Time Complexities</h3>
        <ul>
          <li>Access: O(1) (average case)</li>
          <li>Insert: O(1) (average case)</li>
          <li>Delete: O(1) (average case)</li>
          <li>Search by key: O(1) (average case)</li>
        </ul>
        
        <h3>When to Use</h3>
        <p>
          Use dictionaries when you need to associate values with keys and require fast lookups. They're
          excellent for counting frequencies, caching results, or implementing many algorithms.
        </p>
        
        <h2>Sets</h2>
        <p>
          Sets are unordered collections of unique elements with fast membership testing.
        </p>
        
        <h3>Time Complexities</h3>
        <ul>
          <li>Add: O(1) (average case)</li>
          <li>Remove: O(1) (average case)</li>
          <li>Membership test: O(1) (average case)</li>
        </ul>
        
        <h3>When to Use</h3>
        <p>
          Use sets when you need to ensure uniqueness of elements and perform frequent membership tests,
          unions, intersections, or differences.
        </p>
        
        <h2>Conclusion</h2>
        <p>
          Choosing the right data structure for your specific use case can significantly improve your 
          code's performance and readability. By understanding the strengths and weaknesses of each 
          data structure, you can make informed decisions when designing your algorithms.
        </p>
      </div>
    </section>
      <section class="blog-post" id="post-5">
          <a class="back-to-posts">
              <i data-feather="arrow-left"></i> Back to all posts
          </a>

          <h1 class="blog-post-title">Understanding Heaps in Data Structures</h1>
          <div class="blog-post-meta">
              <div class="post-date">
                  <i data-feather="calendar"></i>
                  <span>May 15, 2025</span>
              </div>
              <div class="post-tags">
                  <span>Data Structures</span>
                  <span>Algorithms</span>
                  <span>Heaps</span>
              </div>
          </div>

          <div class="blog-post-content">
              <p>
                  A <strong>heap</strong> is a specialized binary tree-based data structure that maintains two key properties: <em>shape</em> and <em>heap order</em>. In a <strong>max-heap</strong>, every parent node’s value is greater than or equal to its children, whereas in a <strong>min-heap</strong>, every parent’s value is less than or equal to its children. The heap is also a <em>complete</em> binary tree, with all levels fully filled except possibly the last, which is populated from left to right.
              </p>

              <h2>Array Representation</h2>
              <p>
                  Heaps are most efficiently implemented using arrays. With 1-based indexing, the root resides at index <code>1</code>, and for any node at index <code>i</code>:
              </p>
              <ul>
                  <li>Parent index: <code>floor(i / 2)</code></li>
                  <li>Left child index: <code>2 * i</code></li>
                  <li>Right child index: <code>2 * i + 1</code></li>
                  <li>Leaf nodes span indices <code>floor(n/2) + 1</code> to <code>n</code> for a heap of size <code>n</code>.</li>
              </ul>

              <h2>Insertion</h2>
              <p>
                  To insert a new element:
              </p>
              <ol>
                  <li>Append it at the end of the array (increase heap size by 1).</li>
                  <li>“Bubble up” the element: while it violates the heap-order with its parent, swap it up.</li>
              </ol>
              <pre><code class="language-cpp">void insert(int val) {
    size++;
    int i = size;
    arr[i] = val;
    while (i > 1 && arr[i/2] < arr[i]) {
        swap(arr[i], arr[i/2]);
        i /= 2;
    }
}</code></pre>

              <h2>Deletion (Extract-Max / Extract-Min)</h2>
              <p>
                  Removing the root (the maximum in a max-heap or minimum in a min-heap) involves:
              </p>
              <ol>
                  <li>Swap the root with the last element and decrease heap size.</li>
                  <li>“Heapify down” from the root: swap with the larger (or smaller) child until order is restored.</li>
              </ol>
              <pre><code class="language-cpp">int extractMax() {
    if (size == 0) throw;
    int root = arr[1];
    arr[1] = arr[size--];
    heapify(1);
    return root;
}

void heapify(int i) {
    int largest = i;
    int l = 2*i, r = 2*i + 1;
    if (l <= size && arr[l] > arr[largest]) largest = l;
    if (r <= size && arr[r] > arr[largest]) largest = r;
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(largest);
    }
}</code></pre>

              <h2>Building a Heap</h2>
              <p>
                  To transform an arbitrary array into a heap in <strong>O(n)</strong> time, call <code>heapify</code> in reverse level order:
              </p>
              <pre><code class="language-cpp">for (int i = n/2; i >= 1; --i) {
    heapify(i);
}</code></pre>

              <h2>Heap Sort</h2>
              <p>
                  Heap sort leverages the heap structure to sort in place:
              </p>
              <ol>
                  <li>Build a max-heap (O(n)).</li>
                  <li>Swap the root with the last element, reduce heap size, and heapify the root (repeat n–1 times).</li>
              </ol>
              <p>Overall time complexity: <strong>O(n log n)</strong>.</p>

              <h2>C++ STL <code>priority_queue</code></h2>
              <p>
                  The STL provides <code>priority_queue</code> as a max-heap by default. Use <code>greater&lt;T&gt;</code> for min-heap behavior.
              </p>
              <pre><code class="language-cpp">#include &lt;queue&gt;
priority_queue&lt;int&gt; pq;              // max-heap
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minpq; // min-heap
</code></pre>
          </div>
      </section>

  </main>

  <footer>
    <div class="container">
      <p>&copy; 2025 Rahul Agarwal. All rights reserved.</p>
    </div>
  </footer>

  <script src="script.js"></script>
  <script>
    // Initialize Feather icons
    feather.replace();
    
    // Handle blog post navigation
    document.addEventListener('DOMContentLoaded', function() {
      // Get all read more links
      const readMoreLinks = document.querySelectorAll('.read-more');
      // Get all back to posts links
      const backLinks = document.querySelectorAll('.back-to-posts');
      // Get the blog listing section
      const blogListing = document.getElementById('blog-listing');
      
      // Add click event to all read more links
      readMoreLinks.forEach(link => {
        link.addEventListener('click', function(e) {
          e.preventDefault();
          // Hide blog listing
          blogListing.style.display = 'none';
          // Show the targeted blog post
          const postId = this.getAttribute('data-post');
          document.getElementById(postId).classList.add('active');
          // Scroll to top
          window.scrollTo(0, 0);
        });
      });
      
      // Add click event to all back links
      backLinks.forEach(link => {
        link.addEventListener('click', function() {
          // Hide all blog posts
          document.querySelectorAll('.blog-post').forEach(post => {
            post.classList.remove('active');
          });
          // Show blog listing
          blogListing.style.display = 'block';
          // Scroll to top
          window.scrollTo(0, 0);
        });
      });
    });
  </script>
</body>
</html>
